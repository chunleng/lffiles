###########
# Options #
###########

set icons on
set incsearch on
set incfilter on
set ratios '2:3'
set number on
set shell 'zsh'
set dirpreviews off
set previewer ~/.config/lf/previewer.sh
set cleaner ~/.config/lf/cleaner.sh
set promptfmt "\033[38;5;240m【  %u  %h 】\033[1m%w \033[38;5;0m\033[48;5;3m%F"


############
# Mappings #
############

# using `$SHELL` and `cd .` to ensure direnv is working
cmd direnv_shell ${{
    $SHELL --interactive --login -c "cd . && $1"
}}
# Remove toggle and clear delete, copy selection or filter
map <esc> :unselect; clear; setfilter

# unmap original (toggle-selection)
map <space>
map <space>b $btop
map <space>g :direnv_shell "NOAERIAL=1 EDITOR='nvim +startinsert' lazygit"
map <space>j+ $autojump -i 100
map <space>j- $autojump -d 100
map <space>j? $autojump -s|less
map <enter> %{{
    echo "Jump to: "
    read response
    lf -remote "send ${id} cd '$(autojump $response)'"
}}

# extract zip
map <space>zx %{{
    mimetype="$( file --dereference --brief --mime-type -- "$f" )"
    if [[ $mimetype = "application/x-tar" || $mimetype = "application/gzip" || $mimetype = "application/zip" ]]; then
        extract_filename=$(basename $f)
        extract_path=./${extract_filename%%.*}
        path_backoff=$(test -e ${extract_path} && echo 1)

        if test -n "${path_backoff}"; then
            while test -e ${extract_path}${path_backoff}; do
                path_backoff=$((path_backoff + 1))
            done
            extract_path=${extract_path}${path_backoff}
        fi
        mkdir -p "${extract_path}"
        tar -xf $f --directory "${extract_path}"
        echo "Extracted to ${extract_path}"
    else
        echo "Extraction of this filetype is not supported"
    fi
}}
cmd zip %{{
    if [[ $fs == "" ]]; then
        echo "Please select the file to archive"
    else
        zip_name=""
        while [[ $zip_name = "" ]]; do
            echo "Archive Name: "
            read zip_name
        done

        files=""
        for file in ${(f)fs}; do
            if [[ "${PWD}" != "$(dirname $file)" ]]; then
                echo "Unable to make archive with selection from different folder"
                exit 1
            fi
            files="${files} '$(basename $file)'"
        done

        case "$1" in
            tar)
                eval "tar -cf \"${zip_name}.tar\"$files";;
            gzip)
                eval "tar -czf \"${zip_name}.tar.gz\"$files";;
            zip)
                eval "zip \"${zip_name}.zip\"$files";;
            *)
                echo "${1} is a supported zip type"
        esac
    fi
}}
# create zip - tar
map <space>zct :zip tar
map <space>zcz :zip zip
map <space>zcg :zip gzip
map <c-space> ${{
    selected=$(fd --no-ignore|fzf || echo .)
    lf -remote "send ${id} cd $(dirname ${selected})"
    lf -remote "send ${id} select $(basename ${selected})"
}}

map <tab> :toggle; down
map <backtab> :up; toggle
map <c-h> :set hidden!
map <c-n> :down
map <c-p> :up

map a %{{
    echo "File or Dir/: "
    read r
    [[ $r = */ ]] && mkdir -p $r || (mkdir -p `dirname $r` && touch $r)
}}

map e ${{
    filepath=$(test -z "$f" -o -d "$f" || echo "'$f'")
    lf -remote "send ${id} direnv_shell \"nvim ${filepath}\""
}}
map f :filter
map F
map gd :cd ~/Downloads/
# Vim plugin folder
map gv :cd ~/.local/share/nvim/site/pack/packer
map gw :cd ~/workspace-bootstrap
map gt %{{
    echo "Go to: "
    read response
    lf -remote "send ${id} cd  $response"
}}
map R :reload
# Select all
map V :unselect; invert
map x delete

cmd chmod $eval "chmod $1 $f"
map +r :chmod +r; reload
map -r :chmod -r; reload
map +w :chmod +w; reload
map -w :chmod -w; reload
map +x :chmod +x; reload
map -x :chmod -x; reload

# <space>c for code template function
# <space>cp for python
cmd poetry_init ${{
    set -eu
    trap 'catch' ERR
    function catch() {
        read 'response?Project init failed...'
        exit 1
    }

    package_to_install=""
    for package in "$@"; do
        package_to_install="${package_to_install} --dependency=${package}"
    done

    echo
    latest_python=$(asdf latest python)
    read 'path_name?Choose folder name: '
    read "py_version?Choose Python version (${latest_python}): "

    if [ -z "${py_version}" ]; then
        py_version=${latest_python}
    fi

    mkdir -p ${path_name}
    cd ${path_name}
    asdf local python ${py_version} || \
        (echo 'Python version not yet installed, installing now...' && \
         asdf install python ${py_version} && \
         asdf local python ${py_version} && \
         pip install poetry)

    if [ $? -eq 0 ]; then
        # Standard structure
        mkdir ${path_name}
        touch ${path_name}/__init__.py
        touch main.py
        touch README.md
        echo '.venv' > .gitignore
        git init

        poetry config virtualenvs.in-project true --local
        eval poetry init -n \
            --dev-dependency=pyright \
            --dev-dependency=isort \
            --dev-dependency=black \
            ${package_to_install}
        poetry install

        # Direnv setup
        echo '# Since we are expecting the virtualenv to be in the same folder,
# we need to make poetry create the virtualenv in the same folder by doing the following
#   poetry config virtualenvs.in-project true
export VIRTUAL_ENV=`pwd`/.venv
export PATH=${VIRTUAL_ENV}/bin:${PATH}' > .envrc
        direnv allow .
    fi
}}
map <space>cpp :poetry_init
map <space>cpf :poetry_init fastapi

# <space>cj for java
cmd gradle_init ${{
    set -eu
    trap 'catch' ERR
    function catch() {
        read 'response?Project init failed...'
        exit 1
    }

    echo
    example_java='oracle-19.0.2'
    read 'path_name?Choose folder name: '
    read "java_version?Choose Java version (${example_java}): "

    if [ -z "${java_version}" ]; then
        java_version=${example_java}
    fi

    mkdir -p ${path_name}
    cd ${path_name}
    asdf local java ${java_version} || \
        (echo 'Java version not yet installed, installing now...' && \
         asdf install java ${java_version} && \
         asdf local java ${java_version})

    if [ $? -eq 0 ]; then
        gradle init \
            --type java-application \
            --test-framework junit-jupiter \
            --dsl groovy \
            --project-name `basename ${path_name}` \
            --package `basename ${path_name}`
    fi
}}
map <space>cjj :gradle_init
# vim: syntax=vim:commentstring=#\ %s
